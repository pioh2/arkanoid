# Требования к игровому движку

## Основные принципы
1. Единый движок, работающий на сервере через Bun
2. Разделение режимов реального времени и симуляции
3. Разделение физики и рендеринга
4. Клиент только для отображения и ввода

## Серверная часть
1. Запуск всех инстансов движка на сервере через Bun
2. Два режима работы:
   - Режим реального времени для игры человека
   - Режим симуляции для тренировки AI
3. Поддержка 32 параллельных симуляций для обучения
4. Случайные параметры для каждой симуляции:
   - Случайное разрешение (800x600 - 2560x1440)
   - Передача W и H в пикселях в нейросеть
5. Непрерывное обучение даже при подключенных клиентах
6. Хранение лучшей модели и её автоматическое обновление
7. Создание отдельной игры для каждого клиента

## Временные шаги
### Режим реального времени
1. Расчет физики с реальным dt между шагами
2. Минимальный интервал между шагами - 1мс
3. При отставании - расчет с актуальным dt
4. Состояние отправляется клиенту для рендеринга

### Режим симуляции (AI)
1. Фиксированный dt = 1мс для каждого шага
2. Максимально быстрое выполнение без привязки к времени
3. Отсутствие задержек между шагами
4. Отсутствие передачи состояния клиенту

## Клиентская часть
1. Сохранение существующей логики рендеринга из старого кода
2. Отправка событий клавиш на сервер:
   - keydown/keyup события
   - Состояние каждой клавиши (нажата/не нажата)
3. Рендеринг как в старом коде
4. Поддержка параметра ?start в URL
5. Перезагрузка для загрузки новой модели

## Управление
1. Клиент отправляет состояние клавиш на сервер
2. Сервер хранит актуальное состояние клавиш
3. Физика на сервере использует текущее состояние
4. Для AI - прямое управление от нейросети

## Синхронизация
1. WebSocket соединение для каждого клиента
2. Клиент -> Сервер:
   - События клавиш
   - Размеры окна
3. Сервер -> Клиент:
   - Текущее состояние игры
   - Обновления каждый кадр
4. Загрузка актуальной модели при старте

## Состояние игры
1. Реальные координаты в пикселях (x, y)
2. Полное копирование при передаче
3. Детерминированные коллизии с учетом dt
4. Состояние клавиш как часть состояния
5. Размеры экрана (W, H) в состоянии
6. Время последнего обновления (режим реальн��го времени)

## Производительность
1. Использование Bun для максимальной производительности
2. Минимизация создания объектов
3. Переиспользование структур данных
4. Оптимизация расчетов физики
5. Эффективное управление памятью
6. Разные подходы к времени:
   - Реальное время: измерение dt
   - Симуляция: фиксированный dt = 1мс

## Обучение AI
1. 32 параллельные симуляции
2. Фиксированный dt = 1мс
3. Разные условия:
   - Размеры экрана (W, H)
   - Разные разрешения
   - Случайные позиции
4. Сохранение лучшей модели
5. Метрики качества:
   - Основная цель: прохождение всей игры
   - Вторичная цель: скорость прохождения
   - До прохождения:
     * Количество заработанных очков
     * Штраф за длительное отсутствие новых очков
     * Штраф за недостаточную активность движения (лево-право)
     * Штраф за длительное неотбивание мяча
     * Штраф за слишком медленное движение мяча
6. Автообновление модели

## Входные данные для AI
1. Размеры экрана (W, H) в пикселях
2. Координаты и скорости объектов
3. Состояние блоков
4. Состояние игры (счет, жизни)

## Технический стек
1. Сервер:
   - Bun для запуска движка
   - WebSocket для коммуникации
   - Многопоточность для симуляций
2. Клиент:
   - Чистый JavaScript
   - Canvas для рендеринга
   - WebSocket для связи
3. Общее:
   - Единый формат данных
   - Бинарная сериализация
   - Эффективный протокол обмена